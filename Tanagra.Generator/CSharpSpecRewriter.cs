using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Tanagra.Generator
{
    public class CSharpSpecRewriter
    {
        Dictionary<string, string> basetypeOverride;
        Dictionary<string, string> structNameOverride;

        public CSharpSpecRewriter()
        {
            basetypeOverride = new Dictionary<string, string>
            {
                { "VkSampleMask", "uint32_t" },
                //{ "VkBool32", "uint32_t" },
                //{ "VkFlags", "uint32_t" },
                { "VkDeviceSize", "uint64_t" },
            };
            
            structNameOverride = new Dictionary<string, string>
            {
                { "void",     "IntPtr"  },
                { "char",     "Char"    },
                { "float",    "Single"  },
                { "uint8_t",  "Byte"    },
                { "uint32_t", "UInt32"  },
                { "uint64_t", "UInt64"  },
                { "int32_t",  "Int32"   },
                { "size_t",   "UIntPtr" },
                { "VkBool32", "Boolean" }
            };
        }

        public VkSpec Rewrite(VkSpec spec)
        {
            //
            // `CSharpSpecRewriter` takes a spec generated by `VKSpecReader` and prepares
            // it for C# code generation. Remember that all the type data is linked by `VkType`
            // objects, so changing the name of a struct will change the name in any other structs
            // and all commands where it is referenced.
            //

            foreach(var vkEnum in spec.Enums)
                RewriteEnumDefinition(vkEnum);

            foreach(var vkHandle in spec.Handles)
                RewriteHandleDefinition(vkHandle);

            foreach(var vkStruct in spec.Structs)
                RewriteStructDefinition(vkStruct);

            foreach(var vkCmd in spec.Commands)
                RewriteCommandDefinition(vkCmd);
            
            return spec;
        }
        
        void RewriteHandleDefinition(VkHandle vkHandle)
        {
            if(vkHandle.Name.StartsWith("Vk"))
                vkHandle.Name = vkHandle.Name.Remove(0, 2); // trim `Vk`
        }

        void RewriteStructDefinition(VkStruct vkStruct)
        {
            var name = vkStruct.Name;

            if(structNameOverride.ContainsKey(name))
                name = structNameOverride[name];

            if(name.StartsWith("Vk"))
                name = name.Remove(0, 2); // trim `Vk`

            vkStruct.Name = name;

            for(var x = 0; x < vkStruct.Members.Length; x++)
            {
                var member = vkStruct.Members[x];
                var memberName = member.Name;
                if(member.PointerRank != 0)
                    memberName = memberName.TrimStart(new[] { 'p' });

                if (memberName.Contains('['))
                    memberName = memberName.Substring(0, memberName.IndexOf('['));
                
                memberName = char.ToUpper(memberName[0]) + memberName.Substring(1);
                member.Name = memberName;
            }

            
        }
        
        void RewriteEnumDefinition(VkEnum vkEnum)
        {
            if(vkEnum.Name.StartsWith("Vk"))
                vkEnum.Name = vkEnum.Name.Remove(0, 2); // trim `Vk`

            var expand = string.Empty; //vkEnum.Expand; TODO
            // Add one to the length to deal with the trailing underscore. ie: {VK_EXPAND_NAME_}VALUE_NAME
            var expandLen = (!string.IsNullOrEmpty(expand)) ? expand.Length + 1 : 0;
            foreach(var vkEnumValue in vkEnum.Values)
            {
                var name = vkEnumValue.Name;
                if(!string.IsNullOrEmpty(expand) && name.StartsWith(expand))
                    name = name.Substring(expandLen, name.Length - expandLen);

                if(name.StartsWith("VK_"))
                    name = name.Substring(3, name.Length - 3);

                vkEnumValue.Name = name;
            }

            // After the we've renamed all the enum values, check if there are any that
            // begin with a number (invalid in C#) and fix it.
            if(vkEnum.Values.Any(x => Regex.IsMatch(x.Name, "^[0-9]")))
            {
                foreach(var vkEnumValue in vkEnum.Values)
                {
                    var name = vkEnumValue.Name;
                    name = vkEnum.Name + name;
                    vkEnumValue.Name = name;
                }
            }
        }

        void RewriteCommandDefinition(VkCommand vkCommand)
        {
            if(vkCommand.Name.StartsWith("vk"))
                vkCommand.Name = vkCommand.Name.Remove(0, 2); // trim `Vk`

            for(var x = 0; x < vkCommand.Parameters.Length; x++)
            {
                var param = vkCommand.Parameters[x];
                var paramName = param.Name;
                
                if(param.PointerRank != 0)
                    paramName = paramName.TrimStart(new[] { 'p' });

                paramName = char.ToLower(paramName[0]) + paramName.Substring(1);

                if (paramName == "event" || paramName == "object")
                    paramName = '@' + paramName; // alias names

                param.Name = paramName;
            }
        }
    }
}
